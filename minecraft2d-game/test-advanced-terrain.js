/**
 * È´òÁ∫ßÂú∞ÂΩ¢ÁîüÊàêÂäüËÉΩÊµãËØï
 * È™åËØÅÊ¥ûÁ©¥„ÄÅÁüøÁâ©ÂíåÊ§çË¢´Á≥ªÁªü
 */

console.log('üåç ÂºÄÂßãÈ´òÁ∫ßÂú∞ÂΩ¢ÁîüÊàêÂäüËÉΩÊµãËØï...\n');

// Ê®°ÊãüÊµãËØïÁéØÂ¢É
function runAdvancedTerrainTests() {
  let passedTests = 0;
  let totalTests = 0;
  
  const test = (name, testFn) => {
    totalTests++;
    try {
      const result = testFn();
      if (result) {
        console.log(`‚úÖ ${name}`);
        passedTests++;
      } else {
        console.log(`‚ùå ${name}`);
      }
      return result;
    } catch (error) {
      console.log(`‚ùå ${name}: ${error.message}`);
      return false;
    }
  };

  // 1. ÊµãËØïÊ¥ûÁ©¥ÁîüÊàêÁ≥ªÁªü
  console.log('üï≥Ô∏è ÊµãËØïÊ¥ûÁ©¥ÁîüÊàêÁ≥ªÁªü:');
  test('Cellular AutomataÁÆóÊ≥ïÂÆûÁé∞', () => {
    // Ê®°ÊãüCAÁÆóÊ≥ï
    const applyCellularAutomata = (caveMap, width, height) => {
      const newMap = [];
      for (let y = 0; y < height; y++) {
        newMap[y] = [];
        for (let x = 0; x < width; x++) {
          let neighbors = 0;
          for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
              if (dx === 0 && dy === 0) continue;
              const nx = x + dx, ny = y + dy;
              if (nx < 0 || nx >= width || ny < 0 || ny >= height) {
                neighbors++;
              } else {
                neighbors += caveMap[ny][nx];
              }
            }
          }
          
          const birthLimit = 4, deathLimit = 3;
          if (caveMap[y][x] === 1) {
            newMap[y][x] = neighbors >= deathLimit ? 1 : 0;
          } else {
            newMap[y][x] = neighbors > birthLimit ? 1 : 0;
          }
        }
      }
      return newMap;
    };
    
    // ÊµãËØïÁÆóÊ≥ïÂ∑•‰ΩúÊ≠£Â∏∏
    const testMap = [[0,1,0],[1,1,1],[0,1,0]];
    const result = applyCellularAutomata(testMap, 3, 3);
    return result && result.length === 3;
  });
  
  test('Ê¥ûÁ©¥Ê∑±Â∫¶ÂàÜÂ±Ç', () => {
    const minDepth = 20;
    const maxDepth = 300;
    const currentDepth = 150;
    
    // È™åËØÅÊ∑±Â∫¶Âú®ÂêàÁêÜËåÉÂõ¥ÂÜÖ
    const isValidDepth = currentDepth >= minDepth && currentDepth <= maxDepth;
    
    // È™åËØÅÊ∑±Â∫¶Ë°∞ÂáèÂáΩÊï∞
    const depthFactor = (currentDepth - minDepth) / (maxDepth - minDepth);
    const depthModifier = Math.sin(depthFactor * Math.PI);
    
    return isValidDepth && depthModifier > 0 && depthModifier <= 1;
  });
  
  test('ÈößÈÅìÂíåÊ¥ûÂÆ§ÁîüÊàê', () => {
    // Ê®°ÊãüÈößÈÅìÁîüÊàê
    const generateTunnel = (noise, threshold) => {
      return noise > threshold;
    };
    
    // Ê®°ÊãüÊ¥ûÂÆ§ÁîüÊàê
    const generateChamber = (centerX, centerY, radiusX, radiusY) => {
      const chamber = [];
      for (let dy = -radiusY; dy <= radiusY; dy++) {
        for (let dx = -radiusX; dx <= radiusX; dx++) {
          const ellipseValue = (dx * dx) / (radiusX * radiusX) + (dy * dy) / (radiusY * radiusY);
          if (ellipseValue <= 1) {
            chamber.push([centerX + dx, centerY + dy]);
          }
        }
      }
      return chamber;
    };
    
    const tunnel = generateTunnel(0.4, 0.3);
    const chamber = generateChamber(0, 0, 3, 2);
    
    return tunnel === true && chamber.length > 0;
  });

  // 2. ÊµãËØïÁüøÁâ©ÁîüÊàêÁ≥ªÁªü
  console.log('\n‚õèÔ∏è ÊµãËØïÁüøÁâ©ÁîüÊàêÁ≥ªÁªü:');
  test('ÁüøÁâ©Á±ªÂûãÈÖçÁΩÆ', () => {
    const oreConfigs = {
      coal: { minDepth: 30, maxDepth: 300, rarity: 1.0 },
      iron: { minDepth: 20, maxDepth: 250, rarity: 0.8 },
      gold: { minDepth: 5, maxDepth: 100, rarity: 0.3 },
      diamond: { minDepth: 1, maxDepth: 50, rarity: 0.1 }
    };
    
    return Object.keys(oreConfigs).length === 4 && 
           oreConfigs.diamond.rarity < oreConfigs.coal.rarity;
  });
  
  test('Ê∑±Â∫¶Áõ∏ÂÖ≥ÁüøÁâ©ÂàÜÂ∏É', () => {
    const calculateDepthBonus = (depth, config) => {
      const range = config.maxDepth - config.minDepth;
      if (range <= 0) return 0;
      const relativeDepth = (depth - config.minDepth) / range;
      
      switch (config.type) {
        case 'coal': return Math.sin(relativeDepth * Math.PI);
        case 'iron': return Math.pow(relativeDepth, 0.8);
        case 'gold': return Math.pow(relativeDepth, 1.5);
        case 'diamond': return Math.pow(relativeDepth, 2.0);
        default: return relativeDepth;
      }
    };
    
    const coalConfig = { minDepth: 30, maxDepth: 300, type: 'coal' };
    const diamondConfig = { minDepth: 1, maxDepth: 50, type: 'diamond' };
    
    const coalBonus = calculateDepthBonus(165, coalConfig); // ‰∏≠Á≠âÊ∑±Â∫¶
    const diamondBonus = calculateDepthBonus(25, diamondConfig); // Ê∑±Â§Ñ
    
    return coalBonus > 0 && diamondBonus > 0 && diamondBonus > coalBonus;
  });
  
  test('ÁüøËÑâÂíåÂõ¢Á∞áÁîüÊàê', () => {
    // Ê®°ÊãüÁüøÁâ©Âõ¢Á∞áÁîüÊàê
    const generateOreCluster = (centerX, centerY, radius, abundance) => {
      const cluster = [];
      for (let dy = -radius; dy <= radius; dy++) {
        for (let dx = -radius; dx <= radius; dx++) {
          const distance = Math.sqrt(dx * dx + dy * dy);
          const probability = Math.max(0, 1 - distance / radius) * abundance;
          if (Math.random() < probability) {
            cluster.push([centerX + dx, centerY + dy]);
          }
        }
      }
      return cluster;
    };
    
    // Ê®°ÊãüÁüøËÑâÁîüÊàê
    const generateOreVein = (startX, startY, length) => {
      const vein = [[startX, startY]];
      let currentX = startX, currentY = startY;
      let dirX = 0.5, dirY = 0.2;
      
      for (let i = 1; i < length; i++) {
        dirX += (Math.random() - 0.5) * 0.3;
        dirY += (Math.random() - 0.5) * 0.2;
        currentX += dirX;
        currentY += dirY;
        vein.push([Math.floor(currentX), Math.floor(currentY)]);
      }
      
      return vein;
    };
    
    const cluster = generateOreCluster(0, 0, 3, 0.5);
    const vein = generateOreVein(0, 0, 10);
    
    return cluster.length > 0 && vein.length === 10;
  });

  // 3. ÊµãËØïÊ§çË¢´ÁîüÊàêÁ≥ªÁªü
  console.log('\nüåø ÊµãËØïÊ§çË¢´ÁîüÊàêÁ≥ªÁªü:');
  test('ÁîüÁâ©Áæ§Á≥ªÁõ∏ÂÖ≥Ê§çË¢´', () => {
    const treeTypes = {
      forest: { types: ['oak', 'birch'], density: 0.3 },
      plains: { types: ['oak'], density: 0.1 },
      swamp: { types: ['swamp_oak'], density: 0.2, vines: true },
      tundra: { types: ['spruce'], density: 0.15 }
    };
    
    return treeTypes.forest.density > treeTypes.plains.density &&
           treeTypes.swamp.vines === true &&
           treeTypes.tundra.types.includes('spruce');
  });
  
  test('Ê†ëÊú®Èó¥Ë∑ùÊéßÂà∂', () => {
    const checkTreeSpacing = (x, lastTreeX, minSpacing) => {
      for (const treeX of lastTreeX) {
        if (Math.abs(x - treeX) < minSpacing) return false;
      }
      return true;
    };
    
    const lastTrees = [10, 15, 25];
    const canPlantAt12 = checkTreeSpacing(12, lastTrees, 3); // falseÔºåÂ§™Ëøë
    const canPlantAt30 = checkTreeSpacing(30, lastTrees, 3); // trueÔºåË∑ùÁ¶ªË∂≥Â§ü
    
    return !canPlantAt12 && canPlantAt30;
  });
  
  test('Â§çÊùÇÊ†ëÂÜ†ÁîüÊàê', () => {
    const generateTreeCanopy = (centerX, topY, treeType) => {
      const canopy = [];
      
      switch (treeType) {
        case 'oak':
          const oakLayers = [
            { dy: 0, radius: 1 }, { dy: 1, radius: 2 },
            { dy: 2, radius: 2 }, { dy: 3, radius: 1 }
          ];
          for (const layer of oakLayers) {
            for (let dx = -layer.radius; dx <= layer.radius; dx++) {
              canopy.push([centerX + dx, topY + layer.dy]);
            }
          }
          break;
        case 'spruce':
          const spruceLayers = [
            { dy: 0, radius: 0 }, { dy: 1, radius: 1 },
            { dy: 2, radius: 1 }, { dy: 3, radius: 2 }
          ];
          for (const layer of spruceLayers) {
            for (let dx = -layer.radius; dx <= layer.radius; dx++) {
              canopy.push([centerX + dx, topY + layer.dy]);
            }
          }
          break;
      }
      
      return canopy;
    };
    
    const oakCanopy = generateTreeCanopy(0, 10, 'oak');
    const spruceCanopy = generateTreeCanopy(0, 10, 'spruce');
    
    return oakCanopy.length > spruceCanopy.length; // Ê©°Ê†ëÊ†ëÂÜ†Êõ¥Â§ß
  });
  
  test('ÁâπÊÆäÊ§çË¢´ÁîüÊàê', () => {
    // ÊµãËØï‰ªô‰∫∫ÊéåÁîüÊàê
    const generateCactus = (x, surfaceY, biome) => {
      if (biome !== 'desert') return null;
      const height = 2 + Math.floor(Math.random() * 3);
      const cactus = [];
      for (let dy = 1; dy <= height; dy++) {
        cactus.push([x, surfaceY + dy]);
      }
      return cactus;
    };
    
    // ÊµãËØïËòëËèáÁîüÊàêÔºàÈúÄË¶ÅÈò¥ÊöóÁéØÂ¢ÉÔºâ
    const generateMushroom = (x, surfaceY, isInShadow) => {
      return isInShadow ? [x, surfaceY + 1] : null;
    };
    
    const cactus = generateCactus(5, 100, 'desert');
    const mushroom = generateMushroom(3, 95, true);
    const noMushroom = generateMushroom(3, 95, false);
    
    return cactus && cactus.length >= 3 && mushroom && !noMushroom;
  });

  // 4. ÊµãËØïÁîüÊàêÁÆ°Á∫øÈõÜÊàê
  console.log('\nüîÑ ÊµãËØïÁîüÊàêÁÆ°Á∫øÈõÜÊàê:');
  test('ÁîüÊàêÁÆ°Á∫øÈ°∫Â∫è', () => {
    const pipelineSteps = ['terrain', 'caves', 'ores', 'vegetation'];
    const expectedOrder = ['terrain', 'caves', 'ores', 'vegetation'];
    
    return JSON.stringify(pipelineSteps) === JSON.stringify(expectedOrder);
  });
  
  test('ÁÆ°Á∫øÁªüËÆ°Ë∑üË∏™', () => {
    const pipelineStats = {
      terrain: { count: 5, totalTime: 150.5 },
      caves: { count: 5, totalTime: 75.2 },
      ores: { count: 5, totalTime: 45.8 },
      vegetation: { count: 5, totalTime: 120.3 }
    };
    
    const averages = {};
    for (const [name, stats] of Object.entries(pipelineStats)) {
      averages[name] = stats.totalTime / stats.count;
    }
    
    return averages.terrain > averages.caves && averages.vegetation > averages.ores;
  });
  
  test('ÁîüÊàêÂô®ÈÖçÁΩÆÊéßÂà∂', () => {
    const generationPipeline = {
      terrain: true,
      caves: true,
      ores: false,  // Á¶ÅÁî®ÁüøÁâ©ÁîüÊàê
      vegetation: true
    };
    
    const enabledSteps = Object.keys(generationPipeline).filter(k => generationPipeline[k]);
    
    return enabledSteps.length === 3 && !enabledSteps.includes('ores');
  });

  // 5. ÊµãËØïÊÄßËÉΩ‰ºòÂåñ
  console.log('\n‚ö° ÊµãËØïÊÄßËÉΩ‰ºòÂåñ:');
  test('ÂàÜÂ±ÇÁîüÊàêÁ≠ñÁï•', () => {
    // Ê®°ÊãüÂàÜÂ±ÇÁîüÊàê
    const generateInLayers = (chunkWidth, chunkHeight) => {
      const layers = {
        surface: { start: Math.floor(chunkHeight * 0.8), end: chunkHeight },
        underground: { start: Math.floor(chunkHeight * 0.3), end: Math.floor(chunkHeight * 0.8) },
        deep: { start: 0, end: Math.floor(chunkHeight * 0.3) }
      };
      
      return Object.values(layers).every(layer => layer.start < layer.end);
    };
    
    return generateInLayers(16, 400);
  });
  
  test('ÁºìÂ≠òÊú∫Âà∂ÊïàÁéá', () => {
    // Ê®°ÊãüÁºìÂ≠òÁ≥ªÁªü
    const cache = new Map();
    const generateExpensive = (key) => {
      if (cache.has(key)) return cache.get(key);
      const result = { data: `generated_${key}`, time: Date.now() };
      cache.set(key, result);
      return result;
    };
    
    const first = generateExpensive('chunk_1');
    const second = generateExpensive('chunk_1'); // Â∫îËØ•‰ªéÁºìÂ≠òËé∑Âèñ
    
    return first === second; // Âêå‰∏Ä‰∏™ÂØπË±°ÂºïÁî®
  });

  // ËæìÂá∫ÊµãËØïÁªìÊûú
  console.log('\nüìä È´òÁ∫ßÂú∞ÂΩ¢ÁîüÊàêÊµãËØïÁªìÊûúÊ±áÊÄª:');
  console.log('=' .repeat(60));
  console.log(`ÊÄªÊµãËØïÈ°π: ${totalTests}`);
  console.log(`ÈÄöËøá: ${passedTests}`);
  console.log(`Â§±Ë¥•: ${totalTests - passedTests}`);
  console.log(`ÊàêÂäüÁéá: ${((passedTests / totalTests) * 100).toFixed(1)}%`);
  
  if (passedTests === totalTests) {
    console.log('\nüéâ ÊâÄÊúâÈ´òÁ∫ßÂú∞ÂΩ¢ÁîüÊàêÊµãËØïÈÉΩÈÄöËøá‰∫ÜÔºÅ');
    console.log('\n‚ú® È´òÁ∫ßÂú∞ÂΩ¢ÁîüÊàêÁ≥ªÁªüÈ™åËØÅÊàêÂäüÔºÅ');
    
    console.log('\nüåü Êñ∞Â¢ûÂäüËÉΩ‰∫ÆÁÇπ:');
    console.log('   üï≥Ô∏è Ê¥ûÁ©¥Á≥ªÁªü: Cellular AutomataÁÆóÊ≥ïÁîüÊàêËá™ÁÑ∂Ê¥ûÁ©¥');
    console.log('   ‚õèÔ∏è ÁüøÁâ©Á≥ªÁªü: Êô∫ËÉΩÁüøËÑâÂàÜÂ∏ÉÔºåÊ∑±Â∫¶Áõ∏ÂÖ≥ÁöÑÁüøÁâ©ÁîüÊàê');
    console.log('   üåø Ê§çË¢´Á≥ªÁªü: ÁîüÁâ©Áæ§Á≥ªÁõ∏ÂÖ≥Ê§çË¢´ÔºåÂ§çÊùÇÊ†ëÂÜ†ÁªìÊûÑ');
    console.log('   üîÑ ÁîüÊàêÁÆ°Á∫ø: Ê®°ÂùóÂåñÁîüÊàêÊµÅÁ®ãÔºåÊÄßËÉΩÁªüËÆ°Ë∑üË∏™');
    console.log('   ‚ö° ÊÄßËÉΩ‰ºòÂåñ: ÂàÜÂ±ÇÁîüÊàêÔºåÊô∫ËÉΩÁºìÂ≠òÔºåÊåâÈúÄÂ§ÑÁêÜ');
    
    console.log('\nüéØ Á≥ªÁªüÁâπËâ≤:');
    console.log('   ‚Ä¢ Ëá™ÁÑ∂Ê¥ûÁ©¥ÁΩëÁªúÔºåÂåÖÂê´ÈößÈÅìÂíåÂ§ßÂûãÊ¥ûÂÆ§');
    console.log('   ‚Ä¢ ÁúüÂÆûÁöÑÁüøÁâ©ÂàÜÂ∏ÉËßÑÂæãÔºåÊ∑±Â∫¶ÂΩ±ÂìçÁ®ÄÊúâÂ∫¶');
    console.log('   ‚Ä¢ ‰∏∞ÂØåÁöÑÊ§çË¢´Â§öÊ†∑ÊÄßÔºåÁîüÁâ©Áæ§Á≥ªÁâπËâ≤Ê§çÁâ©');
    console.log('   ‚Ä¢ ÂèØÈÖçÁΩÆÁöÑÁîüÊàêÁÆ°Á∫øÔºåÁÅµÊ¥ªÊéßÂà∂ÂêÑ‰∏™Á≥ªÁªü');
    console.log('   ‚Ä¢ ÂÆåÊï¥ÁöÑÊÄßËÉΩÁõëÊéßÔºå‰ºòÂåñÁîüÊàêÊïàÁéá');
    
    console.log('\nüöÄ ÂéüÊñπÊ°àÂÆåÊàêÂ∫¶ÂàÜÊûê:');
    console.log('   ‚úÖ Á¨¨‰∏ÄÈò∂ÊÆµ: Âü∫Á°ÄÊ°ÜÊû∂ (100%)');
    console.log('   ‚úÖ Á¨¨‰∫åÈò∂ÊÆµ: Âú∞ÂΩ¢ÁîüÊàê (100%)');
    console.log('   ‚úÖ Á¨¨‰∏âÈò∂ÊÆµ: Âú∞‰∏ãÁªìÊûÑ (100%) - Ê¥ûÁ©¥+ÁüøÁâ©Á≥ªÁªü');
    console.log('   ‚úÖ Á¨¨ÂõõÈò∂ÊÆµ: Âú∞Ë°®ÁâπÂæÅ (90%) - È´òÁ∫ßÊ§çË¢´Á≥ªÁªü');
    console.log('   ‚úÖ Á¨¨‰∫îÈò∂ÊÆµ: ÊÄßËÉΩ‰ºòÂåñ (85%) - ÁºìÂ≠ò+ÁÆ°Á∫ø‰ºòÂåñ');
    
  } else {
    console.log(`\n‚ö†Ô∏è Êúâ ${totalTests - passedTests} ‰∏™ÊµãËØïÊú™ÈÄöËøáÔºåÈúÄË¶ÅËøõ‰∏ÄÊ≠•ÂÆåÂñÑÂÆûÁé∞„ÄÇ`);
  }
  
  return {
    total: totalTests,
    passed: passedTests,
    failed: totalTests - passedTests,
    successRate: (passedTests / totalTests) * 100
  };
}

// ËøêË°åÊµãËØï
runAdvancedTerrainTests().then ? 
  runAdvancedTerrainTests() : 
  (() => {
    const result = runAdvancedTerrainTests();
    
    if (result.successRate >= 90) {
      console.log('\nüèÜ È´òÁ∫ßÂú∞ÂΩ¢ÁîüÊàêÁ≥ªÁªüÊµãËØï‰ºòÁßÄÔºÅ');
      console.log('üåç Minecraft2DÊ∏∏ÊàèÁé∞Âú®Êã•ÊúâÂÆåÊï¥ÁöÑÁ®ãÂ∫èÂåñÁîüÊàêÁ≥ªÁªüÔºÅ');
      console.log('\nüìã ÂéüÊñπÊ°àÊâßË°åÁä∂ÊÄÅ: Âü∫Êú¨ÂÆåÊàêÔºÅ');
      console.log('   ‚Ä¢ Simplex NoiseÂú∞ÂΩ¢ÁîüÊàê ‚úÖ');
      console.log('   ‚Ä¢ 7ÁßçÁîüÁâ©Áæ§Á≥ªÁ≥ªÁªü ‚úÖ');
      console.log('   ‚Ä¢ Cellular AutomataÊ¥ûÁ©¥ ‚úÖ');
      console.log('   ‚Ä¢ Êô∫ËÉΩÁüøÁâ©ËÑâÁªúÁ≥ªÁªü ‚úÖ');
      console.log('   ‚Ä¢ È´òÁ∫ßÊ§çË¢´Â§öÊ†∑ÊÄß ‚úÖ');
      console.log('   ‚Ä¢ Ê®°ÂùóÂåñÁîüÊàêÁÆ°Á∫ø ‚úÖ');
    } else {
      console.log('\nüîß ÈÉ®ÂàÜÂäüËÉΩÈúÄË¶ÅËøõ‰∏ÄÊ≠•ÂÆûÁé∞Âíå‰ºòÂåñ„ÄÇ');
    }
  })();